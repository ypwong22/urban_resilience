from __future__ import division

from matplotlib import colors, cm
from matplotlib import pyplot as plt
import numpy as np
import pandas as pd
import dask.array as da


def _get_grid_points(x, num_grid_points):
    if num_grid_points is None:
        return da.unique(x)
    else:
        # unique is necessary, because if num_grid_points is too much larger
        # than x.shape[0], there will be duplicate quantiles (even with
        # interpolation)
        return da.array(da.unique(da.percentile(x, np.linspace(0,100, num_grid_points))).compute())


def _get_point_x_ilocs(grid_index, data_index):
    return (np.abs(np.subtract.outer(grid_index, data_index)).argmin(axis=0))


def _get_quantiles(x):
    return np.greater.outer(x, x).sum(axis=1) / x.size


def ice(data, column, predict, num_grid_points=None):
    """
    Generate individual conditional expectation (ICE) curves for a model.

    :param data: the sample data from which to generate ICE curves
    :type data: ``dask.array``

    :param column: the index to the column in ``data`` that will be varied to
        generate ICE curves
    :type column: ``int``

    :param predict: the function that generates predictions from the model.
        Must accept a ``dask.array`` with the same columns as ``data``.
    :type predict: callable

    :param num_grid_points: the number of grid points to use for the independent
        variable of the ICE curves. The independent variable values for the
        curves will be quantiles of the data.

        If ``None``, the values of the independent variable will be the unique
        values of ``data[:, column]``.
    :type num_grid_points: ``None`` or ``int``

    :return: A ``numpy.array`` whose columns are ICE curves.  The row index is the
        independent variable, and the column index is the original data point
        corresponding to that ICE curve.
    :rtype: ``numpy.array``
    """
    x_s = _get_grid_points(data[:, column], num_grid_points)
    ice_data, orig_column = _to_ice_data(data, column, x_s)
    ice_y = da.transpose(predict(ice_data).reshape(data.shape[0], x_s.shape[0]))
    orig_column = orig_column[::len(x_s)]
    x_s = x_s.compute()
    return ice_y, orig_column, x_s


def ice_plot(ice_y, orig_column, x_s, npts_to_plot = 100,
             plot_points=False, point_kwargs=None,
             x_quantile=False, plot_pdp=False,
             centered=False, centered_quantile=0.,
             color_by=None, cmap=None,
             ax=None, pdp_kwargs=None, **kwargs):
    """
    Plot the ICE curves

    :param ice_y: the ICE predicted values generated by :func:`pycebox.ice.ice`
    :type ice_y: ``dask.array``

    :param orig_column: the ICE data column generated by :func:`pycebox.ice.ice`
    :type orig_column: ``dask.array``

    :param npts_to_plot: randomly samples columns of ``ice_data`` to plot.
    :type npts_to_plot: ``int``

    :param plot_points: whether or not to plot the original data points on the
        ICE curves.  In this case, ``point_kwargs`` is passed as keyword
        arguments to plot.
    :type plot_points: ``bool``

    :param x_quantile: if ``True``, the plotted x-coordinates are the quantiles of
        ``x_s``
    :type x_quantile: ``bool``

    :param plot_pdp: if ``True``, plot the partial depdendence plot.  In this
        case, ``pdp_kwargs`` is passed as keyword arguments to ``plot``.

    :param centered: if ``True``, each ICE curve is centered to zero at the
        percentile closest to ``centered_quantile``.
    :type centered: ``bool``

    :param color_by:  A column from the original data array (corresponding
                      to an input feature) to color the lines with.
    :type color_by: ``dask.array``

    :param cmap:
    :type cmap: ``matplotlib`` ``Colormap``

    :param ax: the ``Axes`` on which to plot the ICE curves
    :type ax: ``None`` or ``matplotlib`` ``Axes``

    Other keyword arguments are passed to ``plot``
    """
    n_cols = ice_y.shape[1]
    icols = np.random.choice(n_cols, size= npts_to_plot, replace=False)
    plot_ice_data = ice_y[:, icols].compute()
    plot_orig_column = orig_column[icols].compute()

    if centered:
        quantiles = _get_quantiles(x_s)
        centered_quantile_iloc = np.abs(quantiles - centered_quantile).argmin()
        plot_ice_data = plot_ice_data - plot_ice_data[centered_quantile_iloc, :]

    if x_quantile:
        x = _get_quantiles(x_s)
    else:
        x = x_s

    if plot_points:
        point_x_ilocs = _get_point_x_ilocs(x_s, plot_orig_column)
        point_x = x[point_x_ilocs]
        point_y = plot_ice_data[point_x_ilocs, np.arange(point_x_ilocs.size)]

    if ax is None:
        _, ax = plt.subplots()

    if color_by is not None:
        colors_raw = color_by[icols].compute()
        norm = colors.Normalize(colors_raw.min(), colors_raw.max())
        m = cm.ScalarMappable(norm=norm, cmap=cmap)

        for color_raw, ice_curve in zip(colors_raw, np.array_split(plot_ice_data, n_cols, axis = 1)):
            c = m.to_rgba(color_raw)
            ax.plot(x, ice_curve, c=c, zorder=0, **kwargs)
    else:
        ax.plot(x, plot_ice_data, zorder=0, **kwargs)

    if plot_points:
        ax.scatter(point_x, point_y, zorder=10, **(point_kwargs or {}))

    if plot_pdp:
        pdp_kwargs = pdp_kwargs or {}
        pdp_data = pdp(plot_ice_data)
        ax.plot(x, pdp_data, **pdp_kwargs)

    return ax, x, plot_ice_data, pdp_data


def pdp(ice_data):
    """
    Calculate a partial dependence plot from ICE data

    :param ice_data: the ICE data generated by :func:`pycebox.ice.ice`
    :type ice_data: ``pandas`` ``DataFrame``

    :return: the partial dependence plot curve
    :rtype: ``pandas`` ``Series``
    """
    return ice_data.mean(axis=1)


def _to_ice_data(data, column, x_s):
    """
    Create the DataFrame necessary for ICE calculations
    """
    ice_data = da.repeat(data, x_s.size, axis = 0)
    data_column = ice_data[:, column].copy()
    ice_data[:, column] = da.tile(x_s, data.shape[0])
    return ice_data, data_column
